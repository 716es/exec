# Inter-page communication: window.exec()

A bare minimum function for inter-page communications using hash fragments. 

To load other webpages on different domains only to call one function and to receive the result, it defines hash fragment with specific format of : `#<call-ID>+<call-ARGUMENT>`.

To maintain privacy, the hash fragment which can potentially contain sensitive information is coded to be removed from the browsing history. 

## Usage

Call `window.exec('<other page url with hash fragment>', '<duration in milliseconds>')` and receive the result either by: 1. returned Promise or 2. the text input form value on the page with focus (document.activeElement) which will be updated with the returned result.

### URL with hash fragment
URL with hash fragment

### Duration in milliseconds
Specifying the duration always forces window.exec to use a child window initiated from the current page. By specifying duration in milliseconds, you can call window.exec multiple times by reusing the same window. 

1. Prepare a callee page (a page for limited features)

Place a text or number input form on the page and wrap that input form with an element with ID (call-ID). Also prepare an element to show calculation result: either `<exec-result>` or an element with class name exec-result (`.exec-result`). Lastly, define an event (e.g `.addEventlistner('keydown', ..)`) with an event handler containing the actual features.

```
<div id="calc"><input type="text" onkeydown="document.querySelector('exec-result').innerText=dosomething(this.value);"></div>
<exec-result></exec-result>
```

2. Caller page (actual user interface)

Either call by JS
```
<script>
exec('function-test.com#calc+' + userinput.value).then(function(result){
    // proceed with the 'result'
});
</script>
```

or place text input form with focus. 
```
<button onclick=exec('function-test.com#calc+1')>Take snap</button>
<input autofocus />
```

Note: window.exec() is a wrapper function of window.open(). Thus it's necessary to be called with a user-initiated event e.g onclick, onkeydown.

## Other notes

### Reverse pattern using .opener

If there is a parent window (window.opener) and it matches the URL of the 1st parameter of window.exec(<URL>), that parent window will be used for window.exec() calculation (without calling window.open()). This is reverse usage in terms of the window handling, useful to avoid creating user-initiated events and continuously run some functions in the background.

### Implementation guide: the callee page

There are multiple initial DOM events to initiate javascript for some calculation on the callee page. Currently tested approach to handle them is to catch the bubbled Keydown or Click event (both are custom-generated by window.onexec) on the upper HTML element, such as document.body. While primarily window.onexec() on the callee page looks up a text input that matches the mentioned CSS selector including the call-ID, the target of dispatchEvent always falls back to document.activeElement, which is document.body in most cases if the window has a focus.

When the calculation is finished and the result container (`exec-result` or `.exec-result`) gets updated, the result will be copied by `.innerText`, just after it adds '.copying' class to the element classList. Since innerText ignores element without visibility (`visibility: hidden` or `display: none`), you can create class definition to hide some elements when the copy operation is running.

I'm happy to receive feedbacks (admin@716.es).


