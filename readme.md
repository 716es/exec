# Inter-page communication: window.exec()

A bare minimum function for inter-page communications using hash fragments. 

To load other webpages on different domains only to call one function and to receive the result, it defines hash fragment with specific format of : `#<call-ID>+<call-ARGUMENT>`.

To maintain privacy, the hash fragment which can potentially contain sensitive information is coded to be removed from the browsing history. 

## Usage
### Polyfilling
The script extends `window` object with .exec() method and starts to watch `hashchange` event. There is no JS module at the moment, but you can use import() and 'side effects' import.

- HTML: `<script src="https://exec.as.cr/exec.js"></script>`  
- JS import(): `import('https://exec.as.cr/exec.js')`
- Importing from JSM: `<script type="module">import 'https://exec.as.cr/exec.js'</script>`

### Syntax
```
window.exec('<other page url with hash fragment>', '<duration in milliseconds>')
```

Call the above function and receive the result either by:
1. returned Promise
2. the text input form value on the page with focus (document.activeElement) which will be updated with the returned result.

### Parameters
#### URL with hash fragment
URL with hash fragment

#### Duration in milliseconds
Specifying the duration always forces window.exec to use a child window initiated from the current page. By specifying duration in milliseconds, you can call window.exec multiple times by reusing the same window. 

### Return value
A Promise resolved with the calculation result. 

### Examples

#### As a javascript function
1. Prepare a callee page (a page for limited features)

Place a text or number input form on the page and wrap that input form with an element with ID (call-ID). Also prepare an element to show calculation result: either `<exec-result>` or an element with class name exec-result (`.exec-result`). Lastly, define an event (e.g `.addEventlistner('keydown', ..)`) with an event handler containing the actual features.

```
<div id="calc"><input type="text" onkeydown="document.querySelector('exec-result').innerText=dosomething(this.value);"></div>
<exec-result></exec-result>
```

2. Caller page (actual user interface)

Either call by JS
```
<script>
exec('function-test.com#calc+' + userinput.value).then(function(result){
    // proceed with the 'result'
});
</script>
```

or place text input form with focus. 
```
<button onclick=exec('function-test.com#calc+1')>Take snap</button>
<input autofocus />
```
Note: window.exec() is a wrapper function of window.open(). Thus it's necessary to be called with a user-initiated event e.g onclick, onkeydown.

### Base effects and URL with hash fragment syntax
#### Accepting form inputs: `#+<data>`
The watch feature enables external scripts to enter some data into the input forms in the HTML if the location.hash is given with `#+<data>`. Data part is expected to be encoded with encodeURIComponent().

#### Accepting form focus and/or getting inputs: `#<call-ID>+<data>`
With the hash change in the format of <call-ID>+<data>, the script first looks up the HTMLElement with `#<call-ID>` (`id="<call-id>"`) which contains `<input>` with `[type=text]`, `[type=number]` or `<textarea>`. Nextly, if the previous condition did not match, it searches an element with `[name=<call-ID>]`. If any element that matches the stated condition is found, the first `input` or `textarea` element gets focused, and are updated with `<data>` if provided.

## Other notes

### Reverse pattern using .opener

If there is a parent window (window.opener) and it matches the URL of the 1st parameter of window.exec(<URL>), that parent window will be used for window.exec() calculation (without calling window.open()). This is reverse usage in terms of the window handling, useful to avoid creating user-initiated events and continuously run some functions in the background.

### Implementation guide: the callee page

There are multiple initial DOM events to initiate javascript for some calculation on the callee page. Currently tested approach to handle them is to catch the bubbled Keydown or Click event (both are custom-generated by window.onexec) on the upper HTML element, such as document.body. While primarily window.onexec() on the callee page looks up a text input that matches the mentioned CSS selector including the call-ID, the target of dispatchEvent always falls back to document.activeElement, which is document.body in most cases if the window has a focus.

When the calculation is finished and the result container (`exec-result` or `.exec-result`) gets updated, the result will be copied by `.innerText`, just after it adds `.copying` class to the element classList. Since innerText ignores elements without visibility (`visibility: hidden` or `display: none`), you can create class definition to hide some elements when the copy operation is running.

I'm happy to receive feedbacks (admin@716.es).


